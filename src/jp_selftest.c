/*  =========================================================================
    jp_selftest.c - run selftests

    Runs all selftests.

    -------------------------------------------------------------------------
    Copyright (c) the Contributors as noted in the AUTHORS file.       
    This file is publically available for educational use by mrj!!!    
                                                                       
    This Source Code Form is subject to the terms of the Mozilla Public
    License, v. 2.0. If a copy of the MPL was not distributed with this
    file, You can obtain one at http://mozilla.org/MPL/2.0/.           

################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
    =========================================================================
*/
#define JP_SELFTESTING 1
#include "jp_classes.h"

typedef struct {
    const char *testname;
    void (*test) (bool);
} test_item;

static test_item
all_tests [] = {
    { "jp_app", jp_app_test },
    { "jp_log", jp_log_test },
    { "jp_field", jp_field_test },
    { "jp_sector", jp_sector_test },
    { "jp_crypt_sha1", jp_crypt_sha1_test },
    { "jp_io_renderqueue", jp_io_renderqueue_test },
    { "jp_io_chunk", jp_io_chunk_test },
    { "jp_io_input_input", jp_io_input_input_test },
    { "jp_io_input_joy", jp_io_input_joy_test },
    { "jp_io_input_mouse", jp_io_input_mouse_test },
    { "jp_io_input_kb", jp_io_input_kb_test },
    { "jp_io_data_item", jp_io_data_item_test },
    { "jp_io_data_npc", jp_io_data_npc_test },
    { "jp_io_data_mob", jp_io_data_mob_test },
    { "jp_io_data_texture", jp_io_data_texture_test },
    { "jp_io_data_config", jp_io_data_config_test },
    { "jp_io_data_field", jp_io_data_field_test },
    { "jp_entity_entity", jp_entity_entity_test },
    { "jp_entity_player", jp_entity_player_test },
    { "jp_entity_pickup", jp_entity_pickup_test },
    { "jp_entity_enemy", jp_entity_enemy_test },
    { "jp_timing_event", jp_timing_event_test },
    { "jp_timing_stopwatch", jp_timing_stopwatch_test },
    { "jp_math_matrix", jp_math_matrix_test },
    { "jp_math_quat", jp_math_quat_test },
    { "jp_math_vecxy", jp_math_vecxy_test },
    { "jp_math_vecxyz", jp_math_vecxyz_test },
    { "jp_math_plane", jp_math_plane_test },
    { "jp_container_list", jp_container_list_test },
    { "jp_container_stack", jp_container_stack_test },
    { "jp_container_queue", jp_container_queue_test },
    { "jp_container_map", jp_container_map_test },
    {0, 0}          //  Sentinel
};

//  -------------------------------------------------------------------------
//  Test whether a test is available.
//  Return a pointer to a test_item if available, NULL otherwise.
//

test_item *
test_available(const char *testname)
{
    test_item *item;
    for (item = all_tests; item->test; item++) {
        if (streq(testname, item->testname))
            return item;
    }
    return NULL;
}

//  -------------------------------------------------------------------------
//  Run all tests.
//

static void
test_runall(bool verbose)
{
    test_item *item;
    puts("Running jportalsandbox selftests...\n");
    for (item = all_tests; item->test; item++)
        item->test(verbose);

    puts("Tests passed OK\n");
}

int
main(int argc, char *argv[])
{
    bool verbose = false;
    test_item *test = 0;
    int argn;
    for (argn = 1; argn < argc; argn++) {
        if (streq(argv [argn], "--help")
        ||  streq(argv [argn], "-h")) {
            puts("jp_selftest.c [options] ...");
            puts("  --verbose / -v         verbose test output");
            puts("  --number / -n          report number of tests");
            puts("  --list / -l            list all tests");
            puts("  --test / -t [name]     run only test 'name'");
            puts("  --continue / -c        continue on exception (on Windows)");
            return 0;
        }
        if (streq(argv [argn], "--verbose")
        ||  streq(argv [argn], "-v"))
            verbose = true;
        else
        if (streq(argv [argn], "--number")
        ||  streq(argv [argn], "-n")) {
            puts("32");
            return 0;
        }
        else
        if (streq(argv [argn], "--list")
        ||  streq(argv [argn], "-l")) {
            puts("Available tests:");
            puts("    jp_app");
            puts("    jp_log");
            puts("    jp_field");
            puts("    jp_sector");
            puts("    jp_crypt_sha1");
            puts("    jp_io_renderqueue");
            puts("    jp_io_chunk");
            puts("    jp_io_input_input");
            puts("    jp_io_input_joy");
            puts("    jp_io_input_mouse");
            puts("    jp_io_input_kb");
            puts("    jp_io_data_item");
            puts("    jp_io_data_npc");
            puts("    jp_io_data_mob");
            puts("    jp_io_data_texture");
            puts("    jp_io_data_config");
            puts("    jp_io_data_field");
            puts("    jp_entity_entity");
            puts("    jp_entity_player");
            puts("    jp_entity_pickup");
            puts("    jp_entity_enemy");
            puts("    jp_timing_event");
            puts("    jp_timing_stopwatch");
            puts("    jp_math_matrix");
            puts("    jp_math_quat");
            puts("    jp_math_vecxy");
            puts("    jp_math_vecxyz");
            puts("    jp_math_plane");
            puts("    jp_container_list");
            puts("    jp_container_stack");
            puts("    jp_container_queue");
            puts("    jp_container_map");
            return 0;
        }
        else
        if (streq(argv [argn], "--test")
        ||  streq(argv [argn], "-t")) {
            argn++;
            if (argn >= argc) {
                fprintf(stderr, "--test needs an argument\n");
                return 1;
            }
            test = test_available(argv [argn]);
            if (!test) {
                fprintf(stderr, "%s not valid, use --list to show tests\n", argv [argn]);
                return 1;
            }
        }
        else
        if (streq(argv [argn], "--continue")
        ||  streq(argv [argn], "-c")) {
#ifdef _MSC_VER
            //  When receiving an abort signal, only print to stderr (no dialog)
            _set_abort_behavior(0, _WRITE_ABORT_MSG);
#endif
        }
        else {
            printf("Unknown option: %s\n", argv [argn]);
            return 1;
        }
    }
    if (test) {
        printf("Running jportalsandbox test '%s'...\n", test->testname);
        test->test(verbose);
    }
    else
        test_runall(verbose);

    return 0;
}
/*
################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
*/
